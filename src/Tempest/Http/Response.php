<?php namespace Tempest\Http;

use Exception;
use Tempest\{
	App, Database\Model, Utility
};

/**
 * A response generated by the HTTP kernel.
 *
 * @author Marty Wallace
 */
class Response extends Message {

	const COOKIE_CREATE = 'CreateCookie';
	const COOKIE_DELETE = 'DeleteCookie';

	/** @var int */
	private $_status = Status::OK;

	/** @var array */
	private $_cookies = [];

	/**
	 * @return static
	 */
	public static function make() {
		return new static();
	}

	private function __construct() {
		$this->setHeader(Header::CONTENT_TYPE, ContentType::TEXT_PLAIN);
	}

	/**
	 * Sets the response status.
	 *
	 * @param int $value The response status.
	 *
	 * @return $this
	 */
	public function setStatus($value) {
		$this->_status = $value;
		return $this;
	}

	/**
	 * Convenience method to set the Content-Type header.
	 *
	 * @param string $value The content-type to use.
	 *
	 * @return $this
	 */
	public function setType($value) {
		return $this->setHeader(Header::CONTENT_TYPE, $value);
	}

	/**
	 * Convenience method to send plain-text.
	 *
	 * @param string $value The text to send.
	 *
	 * @return $this
	 */
	public function text($value) {
		return $this->setType(ContentType::TEXT_PLAIN)
			->setBody($value);
	}

	/**
	 * Convenience method to return the result of {@link Twig::render() rendering a Twig template}.
	 *
	 * @param string $template The template to render.
	 * @param array $context Data to provide to the rendered template.
	 *
	 * @return $this
	 */
	public function render($template, array $context = []) {
		return $this->setType(ContentType::TEXT_HTML)
			->setBody(App::get()->twig->render($template, $context));
	}

	/**
	 * Convenience method to send JSON encoded representation of an array or object.
	 *
	 * @param mixed $data The data to be encoded.
	 *
	 * @return $this
	 */
	public function json($data) {
		return $this->setType(ContentType::APPLICATION_JSON)
			->setBody(json_encode($data));
	}

	/**
	 * Convenience method to send a model as JSON. If the provided value is NULL, an empty JSON object is sent alongside
	 * a 404 Not Found status.
	 *
	 * @param mixed $model The model to send. In most cases this will be a
	 * {@link \Tempest\Database\Model database model} but can be any value that is serializable as JSON.
	 *
	 * @return $this
	 */
	public function model($model) {
		if (!empty($model)) {
			return $this->json($model);
		}

		return $this->setStatus(Status::NOT_FOUND)->json([]);
	}

	/**
	 * Convenience method to set the Location header and a {@link Status::TEMPORARY_REDIRECT 307 Temporary Redirect} or
	 * {@link Status::PERMANENT_REDIRECT 308 Permanent Redirect} HTTP status.
	 *
	 * @param string $location The redirect location.
	 * @param bool $permanent Whether or not the redirect is permanent.
	 *
	 * @return $this
	 */
	public function redirect($location, $permanent = false) {
		return $this->setStatus($permanent ? Status::PERMANENT_REDIRECT : Status::TEMPORARY_REDIRECT)
			->setHeader(Header::LOCATION, $location);
	}

	/**
	 * Convenience method to set the Refresh header.
	 *
	 * @param string $location The location to redirect to after the provided time.
	 * @param int $seconds The amount of seconds to pass before the redirect.
	 *
	 * @return $this
	 */
	public function flash($location, $seconds = 5) {
		return $this->setHeader(Header::REFRESH, $seconds . '; url=' . $location);
	}

	/**
	 * Convenience method to set the Content-Disposition header for file downloads.
	 *
	 * @param string $filename The download filename.
	 *
	 * @return $this
	 */
	public function download($filename) {
		return $this->setHeader(Header::CONTENT_DISPOSITION, 'attachment; filename="' . $filename . '"');
	}

	/**
	 * Sets the response body to the content of a file, alongside the correct headers for that file type. If the file
	 * does not exist, a 404 response status is sent instead.
	 *
	 * @param string $path The path to the file to send.
	 *
	 * @return $this
	 */
	public function file($path) {
		if (file_exists($path)) return $this->setBody(file_get_contents($path))->setType(mime_content_type($path));
		else return $this->setStatus(Status::NOT_FOUND);
	}

	/**
	 * Sets the response body to the value of print_r or var_dump applied to the target object.
	 *
	 * @param mixed $object The object to debug.
	 * @param string $mode The debugging mode - either "print_r" or "var_dump".
	 *
	 * @return $this
	 */
	public function dump($object, $mode = 'print_r') {
		return $this->text(Utility::buffer(function() use ($object, $mode) {
			if ($mode === 'print_r') print_r($object);
			else if ($mode === 'var_dump') var_dump($object);
			else throw new Exception('Unknown dump mode "' . $mode . '".');
		}));
	}

	/**
	 * Returns the current response status.
	 *
	 * @return int
	 */
	public function getStatus() {
		return $this->_status;
	}

	/**
	 * Gets the Content-Type header.
	 *
	 * @return string
	 */
	public function getType() {
		return $this->getHeader(Header::CONTENT_TYPE);
	}

	/**
	 * Attach a cookie to the response.
	 *
	 * @param string $name The name of the cookie to set.
	 * @param mixed $value The value to associated with the cookie.
	 * @param int $lifetime The cookie lifetime in seconds.
	 *
	 * @return $this
	 */
	public function addCookie($name, $value, $lifetime = 3600) {
		$this->_cookies[$name] = [self::COOKIE_CREATE, $value, $lifetime];
		return $this;
	}

	/**
	 * Deletes a previously set cookie.
	 *
	 * @param string $name The name of the cookie to delete.
	 *
	 * @return $this
	 */
	public function deleteCookie($name) {
		$this->_cookies[$name] = [self::COOKIE_DELETE];
		return $this;
	}

	/**
	 * Send the response and {@link App::terminate() terminate} the application.
	 *
	 * @throws Exception If output has already been sent, voiding the ability to set response headers.
	 */
	public function send() {
		header_remove(Header::X_POWERED_BY);
		http_response_code($this->_status);

		foreach ($this->getHeaders() as $header => $value) {
			header($header . ': ' . $value);
		}

		foreach ($this->_cookies as $name => $details) {
			$action = array_shift($details);

			if ($action === self::COOKIE_CREATE) setcookie($name, $details[0], time() + $details[1], '/', null, null, true);
			if ($action === self::COOKIE_DELETE) setcookie($name, null, time(), '/');
		}

		echo $this->getBody();

		App::get()->terminate();
	}

}