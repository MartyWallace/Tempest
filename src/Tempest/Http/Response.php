<?php namespace Tempest\Http;

use Exception;
use Tempest\App;
use Tempest\Kernel\Output;
use Tempest\Database\Model;

/**
 * A response generated by the HTTP kernel.
 *
 * @author Marty Wallace
 */
class Response extends Message implements Output {

	const COOKIE_CREATE = 'CreateCookie';
	const COOKIE_DELETE = 'DeleteCookie';

	/** @var int */
	private $_status = Status::OK;

	/** @var array */
	private $_cookies = [];

	/**
	 * @return static
	 */
	public static function make() {
		return new static();
	}

	private function __construct() {
		$this->setHeader(Header::CONTENT_TYPE, ContentType::TEXT_PLAIN);
	}

	/**
	 * Sets the response status.
	 *
	 * @param int $value The response status.
	 *
	 * @return $this
	 */
	public function setStatus($value) {
		$this->_status = $value;
		return $this;
	}

	/**
	 * Convenience method to set the Content-Type header.
	 *
	 * @param string $value The content-type to use.
	 *
	 * @return $this
	 */
	public function setType($value) {
		return $this->setHeader(Header::CONTENT_TYPE, $value);
	}

	/**
	 * Convenience method to send plain-text.
	 *
	 * @param string $value The text to send.
	 *
	 * @return $this
	 */
	public function text($value) {
		return $this->setType(ContentType::TEXT_PLAIN)
			->setBody($value);
	}

	/**
	 * Convenience method to return the result of {@link Twig::render() rendering a Twig template}.
	 *
	 * @param string $template The template to render.
	 * @param array $context Data to provide to the rendered template.
	 *
	 * @return $this
	 */
	public function render($template, array $context = []) {
		return $this->setType(ContentType::TEXT_HTML)
			->setBody(App::get()->twig->render($template, $context));
	}

	/**
	 * Convenience method to send JSON encoded representation of an array or object.
	 *
	 * @param mixed $data The data to be encoded.
	 *
	 * @return $this
	 */
	public function json($data) {
		return $this->setType(ContentType::APPLICATION_JSON)
			->setBody(json_encode($data));
	}

	/**
	 * Convenience method to set the Location header and a {@link Status::TEMPORARY_REDIRECT 307 Temporary Redirect} or
	 * {@link Status::PERMANENT_REDIRECT 308 Permanent Redirect} HTTP status.
	 *
	 * @param string $location The redirect location.
	 * @param bool $permanent Whether or not the redirect is permanent.
	 *
	 * @return $this
	 */
	public function redirect($location, $permanent = false) {
		return $this->setStatus($permanent ? Status::PERMANENT_REDIRECT : Status::TEMPORARY_REDIRECT)
			->setHeader(Header::LOCATION, $location);
	}

	/**
	 * Convenience method to set the Refresh header.
	 *
	 * @param string $location The location to redirect to after the provided time.
	 * @param int $seconds The amount of seconds to pass before the redirect.
	 *
	 * @return $this
	 */
	public function flash($location, $seconds = 5) {
		return $this->setHeader(Header::REFRESH, $seconds . '; url=' . $location);
	}

	/**
	 * Convenience method to set the Content-Disposition header for file downloads.
	 *
	 * @param string $filename The download filename.
	 *
	 * @return $this
	 */
	public function download($filename) {
		return $this->setHeader(Header::CONTENT_DISPOSITION, 'attachment; filename="' . $filename . '"');
	}

	/**
	 * Sets the response body to the content of a file, alongside the correct headers for that file type. If the file
	 * does not exist, a 404 response status is sent instead.
	 *
	 * @param string $path The path to the file to send.
	 *
	 * @return $this
	 */
	public function file($path) {
		if (file_exists($path)) return $this->setBody(file_get_contents($path))->setType(mime_content_type($path));
		else return $this->setStatus(Status::NOT_FOUND);
	}

	/**
	 * Returns the current response status.
	 *
	 * @return int
	 */
	public function getStatus() {
		return $this->_status;
	}

	/**
	 * Gets the Content-Type header.
	 *
	 * @return Header
	 */
	public function getType() {
		return $this->getHeader(Header::CONTENT_TYPE);
	}

	/**
	 * Attach a cookie to the response.
	 *
	 * @param string $name The name of the cookie to set.
	 * @param mixed $value The value to associated with the cookie.
	 * @param int $lifetime The cookie lifetime in seconds.
	 *
	 * @return $this
	 */
	public function addCookie($name, $value, $lifetime = 3600) {
		$this->_cookies[$name] = [self::COOKIE_CREATE, $value, $lifetime];
		return $this;
	}

	/**
	 * Deletes a previously set cookie.
	 *
	 * @param string $name The name of the cookie to delete.
	 *
	 * @return $this
	 */
	public function deleteCookie($name) {
		$this->_cookies[$name] = [self::COOKIE_DELETE];
		return $this;
	}

	/**
	 * Send the response and {@link App::terminate() terminate} the application.
	 *
	 * @throws Exception If output has already been sent, voiding the ability to set response headers.
	 */
	public function send() {
		header_remove(Header::X_POWERED_BY);
		http_response_code($this->_status);

		foreach ($this->getHeaders() as $header) {
			header($header->getName() . ': ' . $header->getValue());
		}

		foreach ($this->_cookies as $name => $details) {
			$action = array_shift($details);

			if ($action === self::COOKIE_CREATE) setcookie($name, $details[0], time() + $details[1], '/', null, null, true);
			if ($action === self::COOKIE_DELETE) setcookie($name, null, time(), '/');
		}

		App::get()->terminate($this->getBody());
	}

}